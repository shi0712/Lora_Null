# 训练后零空间验证说明

## 概述

`verify_trained_null_space.py` 用于验证 LoRA-Null-v2 模型**训练后**的零空间属性，帮助你理解：
1. 训练后零空间属性是否保持
2. 适配器是否学到了有效的更新
3. 适配器对模型输出的实际贡献

## 使用方法

### 基本用法

```bash
# 验证训练后的模型
python verify_trained_null_space.py \
    --trained_model_path save_LoRA_Null_adapter_llama2_PT_128_math_Null_v2_trained/ft \
    --calib_loader_size 16

# 使用更多样本进行验证
python verify_trained_null_space.py \
    --trained_model_path save_LoRA_Null_adapter_llama2_PT_128_math_Null_v2_trained/ft \
    --calib_loader_size 256 \
    --max_activation_samples 200

# 保存统计结果
python verify_trained_null_space.py \
    --trained_model_path save_LoRA_Null_adapter_llama2_PT_128_math_Null_v2_trained/ft \
    --save_stats verification_results.json
```

### 参数说明

- `--trained_model_path`: **必需**，训练后模型路径（通常是 `output_dir/ft`）
- `--calib_dataset`: 校准数据集，默认 `wikitext2`
- `--calib_loader_size`: 校准样本数量，默认 16
- `--max_activation_samples`: 每层收集的激活样本数，默认 100
- `--save_stats`: 保存统计结果的 JSON 文件路径（可选）

## 验证指标详解

### 1. 零空间保持性：`||BX|| / ||X||`

**物理意义**: 训练后，输入投影到 B 空间的幅度

**预期值**:
- ✅ **< 0.1**: 零空间属性保持良好
- ⚠️ **0.1 - 0.5**: 零空间属性有所退化，但仍可接受
- ❌ **> 0.5**: 零空间属性严重退化

**解释**:
- 理论上，如果 BLinear 权重完全冻结，这个值应该和初始化时一样
- 如果这个值显著增大，说明：
  - BLinear 权重被更新了（检查训练代码的参数冻结）
  - 或者数据分布发生了变化

### 2. 适配器有效性：`||ABX|| / ||X||`

**物理意义**: 适配器输出相对于输入的幅度

**预期值**:
- ✅ **> 1e-4**: 适配器学到了有效的更新
- ⚠️ **1e-6 ~ 1e-4**: 适配器更新较小，可能欠拟合
- ❌ **< 1e-6**: 适配器几乎没变化（可能 ALinear 被错误冻结）

**解释**:
- 初始化时 A=0，所以 ABX=0
- 训练后 A 应该更新，所以 ABX ≠ 0
- 这个值越大，说明适配器的贡献越大

### 3. 适配器贡献：`||ABX|| / ||完整输出||`

**物理意义**: 适配器在总输出中的相对贡献

**预期值**:
- ✅ **> 1%**: 适配器对输出有显著影响
- ⚠️ **0.1% ~ 1%**: 适配器影响较小
- ❌ **< 0.1%**: 适配器几乎没有影响

**解释**:
- 总输出 = ABX + W_residual @ X
- 这个比值衡量了适配器在总输出中的重要性
- 如果太小，说明训练可能不够充分

### 4. 权重范数

输出三个权重矩阵的 Frobenius 范数：
- `||B||_F`: BLinear 权重的范数（应该和初始化时接近）
- `||A||_F`: ALinear 权重的范数（训练后应该 > 0）
- `||W_residual||_F`: 残差权重的范数（保持不变）

## 输出示例

```
============================================================
Layer: model.layers.0.self_attn.q_proj
============================================================
输入样本数: 100
输入维度: 4096, 秩: 128, 输出维度: 4096
------------------------------------------------------------
激活值范数:
  ||X|| (avg):           12.345678
  ||BX|| (avg):          0.123456
  ||ABX|| (avg):         0.234567
  ||W_residual @ X||:    11.987654
  ||完整输出||:           12.456789
------------------------------------------------------------
零空间指标:
  ||BX|| / ||X||:        1.000e-02 ✓ 仍然很小
  ||ABX|| / ||X||:       1.900e-02 ✓ 适配器更新有效
------------------------------------------------------------
适配器贡献:
  ||ABX|| / ||输出||:    1.883e-02 (适配器在总输出中的相对贡献)
------------------------------------------------------------
权重范数:
  ||B||_F:               123.456789
  ||A||_F:               45.678901
  ||W_residual||_F:      234.567890
============================================================

============================================================
汇总统计（所有层平均）
============================================================
平均 ||BX|| / ||X||:        9.876e-03
平均 ||ABX|| / ||X||:       2.134e-02
平均适配器贡献比:            1.856e-02
============================================================

📊 结果解读:
------------------------------------------------------------
✅ ||BX|| / ||X|| < 0.1: 零空间属性保持良好
   输入投影到 B 空间后幅度仍然很小，说明 B 仍在近似零空间中

✅ ||ABX|| / ||X|| = 2.13e-02: 适配器学到了有效的更新
   ALinear 权重已经从初始的0更新到有意义的值

✅ 适配器贡献 1.86%: 对模型输出有明显影响
------------------------------------------------------------
```

## 与初始化时的对比

| 指标 | 初始化时 (build_adapter) | 训练后 (verify_trained) |
|------|-------------------------|------------------------|
| `||BX|| / ||X||` | 应该很小 (1e-4 ~ 1e-2) | **应该保持接近** |
| `||ABX|| / ||X||` | ≈ 0 (< 1e-6) | **应该显著增大** (> 1e-4) |
| `||A||_F` | ≈ 0 | **应该 > 0** |
| `||B||_F` | 固定值 | **应该保持不变** |

## 常见问题诊断

### 问题1: `||BX|| / ||X||` 显著增大（> 0.5）

**可能原因**:
- BLinear 权重在训练中被更新了

**检查方法**:
```python
# 查看训练脚本 train_model_freeze_a.py:185-189
if "ALinear" not in n and "BLinear" not in n and p.requires_grad:
    p.requires_grad = False
```

**解决方案**:
- 确保 BLinear 在训练时被正确冻结
- 检查第185行代码逻辑（注意有个 bug：`"ALinear" not in n and "ALinear" not in n"` 应该是 `"ALinear" not in n and "BLinear" not in n"`）

### 问题2: `||ABX|| / ||X||` 很小（< 1e-6）

**可能原因**:
- ALinear 被错误冻结了
- 学习率过小
- 训练步数不够

**检查方法**:
```bash
# 查看训练日志中的可训练参数统计
grep "trainable params" train.log
```

**解决方案**:
- 确保只有 ALinear 和 BLinear 可训练
- 增大学习率或训练更多步数

### 问题3: 适配器贡献很小（< 0.1%）

**可能原因**:
- 适配器秩太小
- 训练不充分
- 学习率太小

**解决方案**:
- 增大 rank (例如从 128 → 256)
- 增加训练 epochs
- 调整学习率

## 完整工作流程示例

```bash
# Step 1: 构建初始适配器
python build_adapter.py \
    --model_id meta-llama/Llama-2-7b-hf \
    --singular_aware_2 \
    --r 128 \
    --save_model \
    --save_path save_LoRA_Null_adapter_llama2_PT_128

# Step 2: 训练模型
sh tools/train_Null_v2_math.sh \
    save_LoRA_Null_adapter_llama2_PT_128 \
    save_LoRA_Null_adapter_llama2_PT_128_math_Null_v2_trained

# Step 3: 验证训练后的零空间属性
python verify_trained_null_space.py \
    --trained_model_path save_LoRA_Null_adapter_llama2_PT_128_math_Null_v2_trained/ft \
    --calib_loader_size 256 \
    --save_stats trained_verification.json

# Step 4: 对比初始化和训练后的统计
python compare_stats.py \  # 需要自己编写对比脚本
    --init_stats init_verification.json \
    --trained_stats trained_verification.json
```

## 理论背景

### 训练中的零空间动态

**初始化时**:
```
y = ABX + W_residual @ X
  = 0 @ (BX) + W @ X     # A=0
  = W @ X                # 保持预训练输出
```

**训练后**:
```
y = A_trained @ (BX) + W @ X
```

**关键问题**: BX 是否仍然很小？

如果 `||BX|| << ||X||` 仍然成立，那么：
- 即使 `A_trained` 很大，`ABX` 仍然相对较小
- 适配器的更新主要在"不重要的方向"上
- 预训练知识得到保护

### 数学验证

设 B 的列空间由协方差矩阵的最小特征向量张成，特征值为 λ₁, λ₂, ..., λᵣ。

那么：
```
E[||BX||²] ≈ Σᵢ λᵢ
E[||X||²] = Σⱼ σⱼ  (所有特征值)
```

比值：
```
||BX|| / ||X|| ≈ sqrt(Σᵢ λᵢ / Σⱼ σⱼ)
```

如果选择最小的 r 个特征值，这个比值应该很小。

训练后，如果 B 保持不变，这个比值不应该显著变化。

## 总结

使用这个脚本，你可以：

1. ✅ **验证零空间保持性**: 确认训练没有破坏零空间结构
2. ✅ **评估适配器有效性**: 确认适配器学到了有意义的更新
3. ✅ **量化适配器贡献**: 理解适配器对最终输出的影响程度
4. ✅ **诊断训练问题**: 发现参数冻结、学习率等问题

这些指标帮助你理解 LoRA-Null-v2 在实际训练中的行为，验证其"在零空间中微调"的核心思想是否得到实现。
